**1과목**
* 객체지향 개념
1.클래스 class: 하나 이상의 공통된 속성과 연산(행위)를 갖는 객체들을 묶음. 객체의 일반적인 type을 의미함.
2.캡슐화 encapsulation: 서로 관련성이 많은 데이터들과 연산operation들을 묶음.
3.객체 object: 필요한 자료 구조와 수행되는 함수들을 가진 하나의 독립된 존재.
4.상속 Inheritance:개별 클래스를 상속 관계로 묶음, 클래스 간의 체계화된 전체 구조를 파악하기 쉽다.
5.인스턴스 instance: 같은 클래스에 속하는 개개의 객체이자 하나의 클래스에서 생성된 객체

* 미들웨어
1.WAS: 애플리케이션 수행 web app server 웹앱
2.MOM: 메세지 지향 message oriented middleware 메시지
3.RPC: 원격 프로시저 호출 remote procedure call 원격리모콘
4.ORB: 네트워크 호출 object request broker .. 얜 왜 네트워크야ㅜ

* UML unified modeling language
- 객체 지향 시스템을 개발할 때 산출물을 명세화, 시각화 , 문서화 하는데 사용된다.
- 개발하는 시스템을 이해하기 쉬운 형태로 표현하여 분석가, 의뢰인, 설계사가 효율적인 의사소통 하게 해준다.
- 개발 방법론이나 프로세스가 아니라 표준화된 모델링 언어이다.

* 모델model
1.개발 대상을 추상화하고 기호나 그림 등으로 시각적으로 표현한다.
2. 모델을 통해 소프트웨어에 대한 이해도를 향상시킬 수 있다.
3.모델을 통해 이해 당사자 간의 의사소통이 향상된다.
4.향후 개발될 시스템을 유추하기 위해 하는 활동이며 주로 개발자가 실행한다.

* CASE computer-aided software engineering
1.구조적 기법
2.프로토타이핑 기술
3.자동프로그래밍 기술
4.정보 저장소 기술
5.분산 처리 기술

* 분산시스템 마스터-슬레이브 master-slave 아키텍처
마스터: 작업을 분리, 배포.. 슬레이브가 반환한 결과값으로부터 최종 결과값을 계산한다.
슬레이브: 요청 작업 처리
네임노드(마스터)는 데이터 노드(슬레이브)에 대한 메타 데이터를 가지고 있다.

* GoF (Gangs of Four) 디자인 패턴
생성패턴 :
빌더(Builder)
프로토타입(Prototype): prototype을 먼저 생성하고 인스턴스 복제
팩토리메서드(FactoryMethod): 상위클래스에서 객체 생성 인터페이스 정의, 하위클래스에서 인스턴스 생성
추상 팩토리(Abstract Factory)
싱글톤(Singleton)

구조패턴 :
브리지(Bridge): 구현부에서 추상층을 분리하여 각자 독립적으로 확장이 가능하게 함
어댑터(Adapter) : 기존에 구현되어있는 클래스에 기능 추가 시 재사용할 수 있도록 중간에서 맞춰줌
컴포지트(Composite)
데코레이터(Decorator)
파사드(Facade)
플라이웨이트(Flyweight)
프록시(Proxy)

행위 패턴 :
방문자(Visitor)
중재자(Mediator) : 객체간의 통제와 지시의 역학을 하는 중재자를 두어 객체지향 목표 달성
책임 연쇄(Chain of Responsibility)
커맨드(Command)
인터프리터(InterPreter)
이터레이터(Iterator)
메멘토(Memento)
옵서버(Observer)
상태(State)
전략(Strategy)
템플릿메서드(Template Method)

* 공통 모듈
-전체 프로그램의 기능 중 특정기능을 처리할 수 있는 실행코드
-자체적으로 컴파일 가능, 다른 프로그램에서 재사용 가능
-여러 기능 및 프로그램에서 공통으로 사용할 수 있는 모듈(예-날짜 처리를 위한 유틸리티 모듈 등)
공통모듈 원칙
-정확성 : 해당 기능이 실제 시스템 구현시 필요한지 아닌지를 알 수 있도록 정확하게 작성
-명확성 : 해당 기능에 대해 일관되게 이해하고 한가지로 해석될 수 있도록 작성
-완전성 : 시스템이 구현될 때 필요하고 요구되는 모든 것을 기술
-일관성 : 공통 기능 간에 상호 충돌이 없도록 작성
-추적성 : 공통 기능에 대한 요구사항 출처와 관련 시스템 등의 유기적 관계에 대한 식별이 가능하도록 작성

* 협약에 의한 설계: 클래스에 대한 여러 가정을 공유하도록 명세한 것
1.선행조건 precondition:  오퍼레이션이 호출되기 전에 참이 되어야 할 조건
2.결과조건 postcondition:  오퍼레이션이 수행된 후 만족하여야 하는 조건
3.불변조건 invariant: 클래스 내부가 실행되는 동안 항상 만족하여야 함(예: 항상 오름차순)

* 사용자 인터페이스 설계
- 사용성이 최우선으로 고려되어야 함
- 효율성 높여야함
- 오류 쉽게 수정할 수 있어야 함
- 피드백 제공해야 함

* 요구사항 모델링
1.애자일 방법
-프로젝트 요구사항은 '기능' 중심
-공정과 도구보다 '개인'과 소통 중시
-'변화'에 유연하고 신속한 대처
-계획보단 '고객'과의 피드백 중시
2.유스케이스 다이어그램
-액터: 시스템과 상호작용하는 모든 외부요소로, 사람이나 외부시스템을 의미함
-사용자 측면에서의 요구사항으로, 사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술
-시스템 액터: 다른 프로젝트에서 이미 개발되어 사용되고 있으며, 본 시스템과 데이터를 주고받는 등 서로 연동되는 시스템
-액터가 인식할 수 없는 시스템 내부의 기능을 하나의 유스케이스로 파악해서는 안된다.
3.시퀀스 다이어그램
XX단계 다이어그램: 물리 화학 등에서 사용. 요구사항과 관계 xx

* 요구 사항 정의 및 분석·설계의 결과물을 표현하기 위한 모델링 과정에서 사용되는 다이어그램(Diagram)
1.Data Flow Diagram
2.UML Diagram
3.E-R Diagram
XX오답 AVL Diagram은 아님XX

* 요구사항 관리 도구의 필요성
1.요구사항 변경으로 인한 비용 편익 분석
2.요구사항 변경의 추적
3.요구사항 변경에 따른 영향 평가
XX오답 기존 시스템과 신규 시스템의 성능 비교는 개발, 설계 등 구현 단계 때 하는 것입니다..XX

* 익스트림 프로그래밍 XP
1.사용자의 스토리 활용: 개발 프로세스 과정에서 고객의 요구사항을 간단하게 시나리오로 작성한 것(간단한 테스트 케이스 포함)
2.빠른 sw 개발이 목적이지만 테스트 안하는건 아니다.
3.기존의 방법론에 비해 실용성pragmatism을 강조한 것이라고 볼 수 있다.

* 요구사항 검증 requirements validation
1.실제로 고객이 원하는 바를 정의했는지
2.시스템을 개발하거나 시스템이 운영 중일 때 발견되면 재작업 비용 크므로 중요함
3.시스템을 변경하여 요구사항을 수정하는 비용>>>> 설계및 코딩 오류때매 발생하는 비용(설계, 구현 변경하고 다시 테스트해야해서)
요구사항 checkList
1.유효성 validity: 요구한게 맞는지 필요를 충족하는지
2.일관성 consistency: 충돌하는거 있는지 ex 모순되는 제약조건
3.완결성 completeness: 요구한게 다 들어갓는지
4.현실성 realism: 예산과 기술적으로 가능한지 (일정 포함)
5.검증 가능성 verifiability: 만들고 난 뒤 요구사항을 검증할 수 있는지(요구사항과 일치 여부)
XX오답 요구사항 검증을 통해 모든 문제를 발견할 수 있다? ㄴㄴ 쌉불가능XX

* 모듈 결합도: 약할수록 good // 응집도: 강할수록 good

* 자료 사전 표기법
1. = : 자료의 정의
2. + : 자료의 연결
3. () : 자료의 생략
4. [|] : 자료의 선택
5. {} : 자료의 반복
6. ** : 자료의 설명(주석)


**2과목**
* 프로그래밍 언어 선택 기준
친밀감, 언어의 능력, 처리의 효율성, 프로그램 구조, 프로그램의 길이, 이식성, 과거의 개발 실적, 알고리즘과 계산상의 난이도, 자료 구조의 난이도, 성능 고려 사항들, 대상 업무의 성격, 소프트웨어의 수행 환경, 개발 담당자의 경험과 지식, 사용자의 요구사항, 컴파일러의 이용 가능성
XX오답 독창성은 기준 아님XX

* 인터페이스 보안을 위해 네트워크 영역에 적용할 수 있는 솔루션
1.IPSec(IP security)
-네트워크 계층에서 IP 패킷 단위의 데이터 변조 방지 및 은닉 기능 제공
2.SSL: TCP/IP 계층과 앱 계층 사이에서 인증, 암호화, 무결성을 보장하는 프로토콜 ..
3.S-HTTP: 클라이언트와 서버 간 전송되는 모든 메시지를 암호화.
XX오답 SMTP : 전자우편 교환 서비스 ㅋㅋ 심플 메일 트랜스퍼 프로토콜

* 소스코드 품질분석 도구
1.정적 분석 도구
1-1.pmd: 코드 결함 분석
1-2.cppcheck: c/c++ 오버플로우 검사
1-3.SonarQube: 중복 코드 복잡도, 코딩 설계 등을 분석함
1-4. ccm: 다양한 언어의 코드 복잡도를 분석함
1-5.checkstyle: java코드 표준 준수 검사
1-6.cobertura: java언어의 복잡도 분석, 테스트 커버리지 측정
2.동적 분석 도구
2-1.valance
2-2.Avalanche: Valgrind 프레임워크 및 STP 기반. 프로그램 결함, 취약점 분석
2-3.Valgrind: 프로그램 내에 존재하는 메모리 및 쓰레드 결함 분석

* 단위 테스트 unit test
-구현 단계에서 각 모듈의 개발을 완료한 후 개발자가 명세서의 내용대로 정확히 구현되었는지 테스트
-모듈 내부의 구조를 구체적으로 볼 수 있는 구조적 테스트를 주로 시행
-테스트할 모듈을 호출하는 모듈(드라이버)도 있고, 테스트할 모듈이 호출하는 모듈(스텁)도 있다.

* 테스트 드라이버 test driver
1.시험대상 모듈을 호출하는 간이 sw
2.필요에 따라 매개변수 전달하고 모듈을 수행한 후의 결과를 보여줄 수 있다.
3.상향식 통합 테스트에서 사용
4.테스트 대상 하위 모듈을 호출하고, 파라미터 전달, 모듈 테스트 수행

* 테스트 스텁 stub
1.테스트 대상 모듈이 호출하는 하위 모듈의 역할을 함
2.제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구
3.하향식 테스트에 사용

* 디지털 저작권 관리 digital right management? 에 사용되는 기술요소
- 암호화/키관리/암호화 파일생성/식별기술/저작권 표현/ 정책관리/크랙방지/인증
XX오답  방화벽 XX

* 소프트웨어 형상 관리 sw configuration magement
1.소프트웨어의 변경 사항을 체계적으로 추적하고 통제하는 것(단순 버전관리보다 포괄적 개념)
2.절차: 형상 식별->형상 통제->형상 감사->형상 기록/보고
2-1.형상 식별: 대상들을 구분하고 번호 부여(대상: 품질관리 계획서, 품질관리 매뉴얼, 요구사항 명세서, 설계/인터페이스 명세서, 테스트 설계서, 소스코드
2-2.형상 통제: 형상 변경 제안을 검토, 현재 sw기준선에 반영하도록 통제, 형상 통제 위원회 의 승인을 통해 변경
2-3.형상 감사: 변경이 제대로 이뤄졋는지 검토/승인, 제3자의 객관적인 확인과 검증(개발자, 유지보수 담당자 x)
2-4.형상 기록/보고: 개발상태에 대한 보고서 제공, 베이스라인 산출물에 대한 변경과 처리 과정에서의 변경을 상태 보고에 모두 기록
- 프로젝트 요구 분석서/ 소스코드/ 운영 및 설치 지침서
XX오답 프로젝트 개발 비용 XX

* 블랙박스 테스트
1.동치분할검사:입력 자료에 초점을 맞춰 케이스를 만들고 검사하는 방법
2.경계값 분석
3.원인-효과 그래프 검사
4.오류 예측 검사
5.비교 검사

* 화이트 박스 테스트(기조루흐)
1.기초 경로 검사
2.조건 검사
3.루프 검사
4.(데이터) 흐름 검사

* 인수 테스트
1.알파 테스트:개발자의 장소에서 사용자가 개발자 앞에서 행하는 테스트 기법
2.베타 테스트:선정된 최종 사용자가 여러명의 사용자 앞에서 행하는 테스트 기법

* 결함 fault
- 오류 및 작동 실패의 원인. 개발자의 설계나 제작 의도와 다르게 동작하게 함.

* 정렬 Sort
1.퀵: 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬
2.삽입: 가장 간단함. 이미 순서화된 파일에 새로운 하나의 레코드를 순서에 맞게 삽입 시킴
3.쉘: 삽입 확장. 입력 파일을 매개 변수 값으로 해서 서브 파일을 구성하고 각 서브 파일을 삽입 방식으로 순서 배열하는 과정을 반복
4.선택 Selection Sort:  선택정렬은 정렬되지 않은 값중 가장 작은 값을 선택 후 정렬되지 않은 첫 번째 요소와 바꾸는 방법
5.버블: 인접한 두개의 레코드 키값을 비교하여 서로 교환
6.힙: 전이진 트리를 이용
7.2-way 합병: 이미 정렬된 두개를 하나로 병합
8.기수 정렬: 키값을 분석하여 같은 값끼리 순서에 맞는 버킷에 분배햇다가 버킷의 순서대로 꺼내 정렬

* 클린 코드 작성 원칙
- 가독성: 누구든 쉽게 이해
- 단순성: 단순, 명료한 코드
- 의존성 배제: 다른 모듈에 미치는 영향 최소화
- 중복성 최소화
- 추상화

* 코드 인스펙션
- 결함 뿐만 아니라 모든 것이 표준대로 되어있는지 확인
- 표준이나 명세서에 서술한 내용과 비교해서 편차, 에러를 식별하기 위해 산출물을 근거로 수행
- 정적 테스트에 가까움

* 트리
- 차수: 특정 노드에 연결된 자식 노드의 수. 언급이 없을 땐 가장 큰 차수.
- 최상단은 차수에 포함 X
- 단말 노드: 자식이 없는 노드

* 트리 운행
중위 Inorder 
전위 Preorder
후위 Postorder

* 스택 연산
-입구 및 출구가 하나.. ABCD 순으로 입력되었을 때 출력 순서는 DCBA 순
push:입력
pop:출력


* sw 버전 관리 도구
RCS(Revision Control System)
- CVS와의 차이점은 소스 파일의 수정을 한 사람만으로 제한한다.
- 다수의 사용자가 동시에 파일 수정을 할 수 없도록 파일 잠금 방식으로 버전을 관리하는 도구이다.
- 다른 방향으로 진행된 개발 결과를 합치거나 변경 내용을 추적할 수 있다.
RPC(Remote Procedure call)
- 별도의 원격 제어를 위한 코딩 없이 다른 주소 공간에서 리모트의 함수나 프로시저를 실행 할 수 있게 해주는 프로세스간 통신

* sw 품질 목표
- 정확성(correctness): 시스템의 사양과 설계, 구현에 있어서 오류가 없는 정도
- 유용성(usability): 사용자가 시스템을 배우고 사용하는 데 있어서의 용이함
- 효율성(efficiency): 메모리와 실행 시간 같은 시스템 리소스의 최소 사용
- 신뢰성(reliability): 정해진 상황에서 언제든지 필요한 기능을 수행할 수 있는 시스템의 능력 - 고장 사이의 시간
- 무결성(integrity): 시스템이 프로그램이나 데이터에 대한 허용되지 않거나 잘못된 접근을 막는 정도. 무결성의 기본 개념에는 데이터의 적절한 접근을 보장할 뿐만 아니라 권한이 없는 사용자의 접근 제한 기능이 포한된다. 즉, 병렬 데이터를 갖는 데이블은 병렬로 변경되고 날짜 필드는 타당한 날짜만을 포함하는 식이다.
- 적응성(adaptablility): 시스템을 변경하지 않고 설계된 환경에서 뿐만 아니라 다른 응용 분야나 환경에서도 사용될 수 있는 정도
- 정밀성(accuracy): 구성된 시스템에 오류가 없는 정도. 특히 대량의 데이터를 고려한다. 정밀성은 정확성과 다르다. 정밀성은 시스템이 정확하게 구성되었는지가 아닌 시스템이 용도대로 얼마나 잘 수행하는지를 결정한다.
- 견고성(robustness): 시스템이 잘못된 입력이나 악조건에서도 기능을 계속해서 수행할 수 있는 정도

**3과목**
* 대충 sql 용어(알면 보지말자)
PRIMARY KEY : 테이블의 기본 키를 정의 / 유일하게 테이블의 각 행을 식별
FOREIGN KEY : 참조 대상을 테이블로 명시 / 외래 키를 정의 / 열과 참조된 테이블의 열 사이의 외래 키 관계를 적용하고 설정
UNIQUE  : 테이블 내에서 얻은 유일한 값을 갖도록 하는 속성
NOT NULL  : 해당 컬럼은 NULL값을 포함하지 않도록 하는 속성
CHECK  : 개발자가 정의하는 제약조건 / 참(TRUE)이어야 하는 조건을 지정
DEFAULT : 해당 필드의 기본값을 설정
Super key(슈퍼키) - 속성들의 집합으로 구성된 키, 릴레이션을 구성하는 모든 튜플들 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타나지 않는다.
Candidate key(후보키) - 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합
UNION ALL : 각 쿼리의 모든 결과를 포함한 합집합 (중복제거 안함)
#### DDL(Data Define Language, 데이터 정의어)
>DDL은 SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 정의하거나 변경 또는 삭제할 때 사용하는 언어이다.
- CREATE: SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 정의한다.
- ALTER: TABLE에 대한 정의를 변경하는 데 사용한다.
- DROP: SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 삭제한다.
#### DML(Data Manipulation Language, 데이터 조작어)
>DML은 데이터베이스 사용자가 응용 프로그램이나 질의어를 통하여 저장된 데이터를 실질적으로 처리하는데 사용되는 언어
데이터베이스 사용자와 데이터베이스 관리시스템 간의 인터페이스를 제공한다.
- SELECT: 테이블에서 조건에 맞는 튜플을 검색한다.
- INSERT: 테이블에 새로운 튜플을 삽입한다.
- DELETE: 테이블에서 조건에 맞는 튜플을 삭제한다.
- UPDATE: 테이블에서 조건에 맞는 튜플의 내용을 변경한다.
#### DCL(Data Control Language, 데이터 제어어)
> DCL은 데이터의 보안, 무결성, 회복, 병행 수행 제어 등을 정의하는 데 사용되는 언어이다.
데이터 베이스 관리자가 데이터 관리를 목적으로 사용한다.
- COMMIT: 명령에 의해 수행된 결과를 실제 물리적 디스크로 저장하고, 데이터베이스 조작 작업이 정상적으로 완료되었음을 관리자에게 알려준다.
- ROLLBACK: 데이터베이스 조작 작업이 비정상적으로 종료되었을 때 원래의 상태로 복구한다.
- GRANT: 데이터베이스 사용자에게 사용권한을 부여한다.
- REVOKE: 데이터베이스 사용자의 권한을 취소한다.

* relation: 테이블의 수
* attribute: 열의 수
* tuple: 행의 수

* 데이터베이스 설계-논리적 단계
-현실 세계에서 발생하는 자료를 컴퓨터가 이해하고 처리할 수 있는 물리적 저장장치에 저장할 수 있도록 변환하기 위해 특정 DBMS가 지원하는 논리적 자료 구조로 변환시키는 과정
-개념 세계의 데이터를 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계로 표현되는 논리적 구조의 데이터로 모델화
-개념 스키마를 평가 및 정제하고 DBMS에 따라 서로 다른 논리적 스키마를 설계하는 단계(종속적인 논리 스키마)
-트랜잭션의 인터페이스 설계
-관계형 데이터베이스라면 테이블 설계
-특정목표 DBMS에 따른 스키마설계
-스키마의 평가 및 정제

* 데이터베이스 설계 단계-물리적 단계
-논리적 구조로 표현된 데이터를 물리적 구조의 데이터로 변환
-데이터 베이스 파일의 저장 구조 및 엑세스 경로 결정
-데이터가 컴퓨터에 저장되는 방법을 묘사
-저장 레코드의 양식 설계, 레코드 집중의 분석 및 설계, 접근 경로 설계
-기본적 데이터 단위는 저장레코드
-성능에 중대한 영향을 미침
1.어떤 인덱스를 만들지 고려
2.성능 향상을 위한 개념 스키마의 변경 여부 검토
3.레코드의 크기
4.파일과 구조 저장을 위한 최소한의 공간
5.빈번한 질의와 트랜잭션들의 수행 속도를 높이기 위한 고려사항
-응답시간
-저장 공간의 효율화
-트랜잭션 처리량

* 병렬 데이터베이스 수평 분할 (파티셔닝)
- 하나의 테이블의 각 행을 다른 테이블에 분산 시키는 것
1.라운드-로빈 분할 round robin : 파티션의 행에 고른 분포를 원할 때 사용. 분할 칼럼 명시할 필요 x. 
회전하면서 새로운 행이 파티션에 할당. 테이블 기본키 반드시 필요x..
2.범위 분할 range
3.해시 분할 hash
4.list
5.composite
XX오답 예측 분할XX

* 시스템 카탈로그
- DBMS가 스스로 생성하고 유지.
- 시스템 자신이 필요로 하는 스키마 및 여러 객체에 관한 정보를 포함하고 있는 시스템 db
- 메타데이터라고도 함

* 물리적 db 구조의 기본 데이터 단위인 저장 레코드의 양식을 설계 할 때 고려할 사항
- 데이터 타입, 데이터 값의 분포, 접근 빈도

* 트랜잭션 모델링 - 개념적 설계 단계에서 수행
- 트랜잭션을 개념적 시스템 독립적으로 정의
- 트랜잭션의 입출력 기능, 형태만 정의
- 검색, 갱신, 혼합(검색, 갱신)

* 정규화
-데이터 구조의 안정성 최대화
-중복 데이터를 최소화하거나 없앰
-수정, 삭제 시 이상현상의 최소화
-테이블 불일치 위험의 최소화
제1정규형(1NF) : 도메인이 원자값만으로 구성된 정규형
2NF : 기본 키가 아닌 모든 속성이 기본 키에 대해 완전 함수적 종속을 만족하는 정규형
|(이행적 종속 제거)
v
3NF : 기본 키가 아닌 모든 속성이 기본 키에 대해 이행적 종속을 만족 하지 않는 정규형
BCNF : 모든 결정자가 후보 키인 정규형
4NF : 다치 종속 A->B가 성립하는 경우 A에 함수적 종속 관계를 만족하는 정규형
5NF : 모든 조인 종속이 후보 키를 통해서만 성립되는 정규형

* 뷰 view
- 뷰 위에 또 다른 뷰를 정의할 수 있다
- DBA는 보안성 측면에서 뷰를 활용할 수 있다
- 사용자가 필요한 정보를 요구에 맞게 가공하여 뷰로 만들 수 있다
- 삽입, 갱신, 삭제 연산 시 제약 사항이 있다(ALTER 사용 불가)

* 트랜잭션
원자성 : 트랜잭션 연산은 DB에 모두 반영되어 Commit(완료)되든지 아니면 반영안되어 Rollback(복구)되어야 한다.
일관성 : 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성있는 데이터베이스 상태로 변환한다.
독립성 : 둘 이상 트랜잭션이 동시 병행 실행될 경우 트랜잭션 실행 중 타 트랜잭션의 연산이 끼어들 수 없다.
지속성 : 성공적 완료된 트랜잭션 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.

* 회복: 트랜잭션 도중에 손상된 데이터베이스를 이전 상태로 복귀하는 작업.
- 트랜잭션 연산을 수행할 때 db를 변경하기 전 로그 데이터를 생성함
- 취소 undo 연산으로 이미 db에 쓰여진 것도 수정할 수 있음
- 장애의 유형: 트랜잭션/시스템/미디어
회복 기법
1.즉각 갱신 기법 immediate update
-트랜잭션의 연산을 수행하여 데이터를 갱신할 때 실제 db에 반영하는 기법
-갱신한 내용을 모두 로그log에 보관
-회복 작업을 위해 취소undo와 재시도 redo 모두 사용 가능
2.연기 갱신 기법 deffered update
-트랜잭션을 완료할 때까지 db 갱신을 연기
-트랜잭션 수행으로 갱신할 내용을 로그log에 보관
-트랜잭션 부분 완료 시점에 log의 기록을 실제 db에 반영
-트랜잭션 수행 중 장애가 발생해 롤백해도 취소 undo 할 필요가 없음
-재시도redo 작업을 통해 최근의 정상적인 db로 회복한 후 트랜잭션 재실행 가능
3.검사점 기법 check point
-트랜잭션 중간에 검사점을 로그에 보관하여 전체를 취소하지 않고 검사점까지 취소할 수 있는 기법
4.그림자 페이지 대체 기법 shadow paging - 로그 필요 X
-트랜잭션의 연산으로 갱신할 필요가 있을 때 복사본인 그림자 페이지를 보관
-로그log, 취소 undo, 재시도 redo 할 필요 없음



* 무결성
- 개체 무결성: 기본키로 지정된 모든 튜플의 속성은 항상 널(Null)값을 가질 수 없다. null->개체무결성

* 분산 데이터 베이스의 투명성 transparency 조건
- 분할 투명성: 하나의 논리적 릴레이션이 여러 단편으로 분할되어 각 단편의 사본이 여러 site에 저장 division
- 위치: 사용하려는 데이터 저장 장소 명시 불필요. 위치 정보는 시스템 카탈로그에 유지되어야 함 location
- 지역사상: 지역dbms와 물리적 db 사이의 맵핑 보장. 각 지역시스템 이름과 무관한 이름 사용 가능 
- 중복: db 객체가 여러 site에 중복되어있는지 알 필요 x replication
- 장애: 구성요서의 장애에 무관하게 원자성 유지 failure
- 병행: 다수 트랜잭션 동시 수행시 결과의 일관성 유지 time stamp, 2pl 구현 concurrency

* E-R 모델의 표현 방법
- 개체 entity 타입: 사각형
- 관계 relation 타입: 마름모
- 속성 attribute 타입: 타원 ..  속성의 수: 차수 degree .. 속성의 집합: 스키마=열 
- 연결: 선
- 튜플의 개수: 카디날리티 cardinality

* 릴레이션 relation 특징
똑같은 튜플 포함안됨
튜플사이 순서 없음
속성간 순서 중요x
속성의 명칭은 유일 구성값은 동일값 가능
속성 값은 원자값

* 함수적 종속
- 어떤 릴레이션 r이 있을 때 x와 y를 각각 속성의 부분집합이라고 할 경우,
x의 값에 y의 값이 달라질 때 y는 x에 함수적 종속이라고 함.
이 경우 x는 결정자, y는 종속자..

**4과목**
* 응집도 순서(강함->약함) 기순교절시논우
기능적->순차적->교환적->절차적->시간적->논리적->우연적
1.기능적(Functional Cohesion) : 모듈 내 모든 요소들이 단일 기능을 수행
2.순차적(Sequential Cohesion) : 모듈 내의 한 요소의 출력 자료가 다음 요소의 입력 자료로 사용
3.교환적(Communication Cohesion) : 모듈 내의 요소들이 동일한 입출력 자료로 서로 다른 기능을 수행
4.절차적(Procedural Cohesion) : 모듈 수행 요소들이 반드시 특정 순서대로 수행
5.시간적(Temporal Cohesion) : 특정 시간에 실행되는 기능들을 모아 작성된 모듈
6.논리적(Logical Cohesion) : 논리적으로 유사한 기능을 수행 하지만 서로의 관계는 밀접하지 않음
7.우연적(Coincidental Cohesion) : 모듈 내 요소들이 뚜렷한 관계가 없이 존재
어떠한 의미 있는 연관관계도 지니지 않은 기능 요소로 구성되고 서로 다른 상위 모듈에 의해 호출되어 처리상의 연관성이 없는 서로 다른 기능을 수행하는 경우

* 소프트웨어의 취약점
1.FTP 바운스 공격: FTP 프로토콜 구조의 허점을 이용한 공격 (네트워크)
2.SQL 삽입: SQL의 논리적 에러를 이용한 공격(웹)
3.버퍼 오버플로: 메모리를 다루는데 오류가 발생하여 잘못된 동작을 함(앱)
4.디렉토리 접근 공격: 웹 루트 디렉토리 외부에 저장된 파일 또는 디렉토리에 접근하는 방법(웹)

* 운영체제
- 커널 kernel: 프로세스(cpu 스케줄링) 관리, 기억장치 관리, 파일관리, 입출력관리, 프로세스 간 통신, 데이터 전송 및 변환
- 쉘 shell: 시스템과 사용자간의 인터페이스 담당. 명령 해석기, 여러종류 있음

* IPv4
32비트 주소
유니캐스트, 멀티캐스트, 브로드캐스트

* IPv6
보안과 인증 확장 헤더를 사용함으로써 인터넷 계층의 보안 기능 강화함
인증성/기밀성/무결성 지원(=보안성 강화)
128비트 주소체계사용
애니캐스트: 하나의 호스트에서 그룹 내의 가장 가까운 곳에 있는 수신자에게 전달
유니캐스트, 멀티캐스트, 애니캐스트
XX오답 패킷 헤더 32octet?아님 어쨌든 아님 ㅠ 뭔진 몰라 XX

* 배치 프로그램의 필수 요소
-대용량 데이터: 를 처리할 수 있어야함 ㅋ
-자동화: 심각한 오류 상황 외에는 사용자의 개입 없이 동작해야함
-견고성: 유효하지 않은 데이터의 경우도 처리해서 비정상적 동장 중단이 발생하지 않아야 함
-안정성: 어떤 문제가 언제 발생했는지 추적 가능해야함
-성능: 주어진 시간 내에 처리를 완료하고 동시에 동작하는 다른 앱을 방해하면 안됨
XX오답.. 무결성XX

* Python 데이터 타입
-시퀀스 타입: 리스트(순서o가변) [1,2,3], 튜플(순서o불변) (1,2,3)
- 세트: 세트(순서x중복x) {1,2,3}
- 맵: 딕셔너리(순서x 키밸류쌍) {'a':1, 'b':2, 'c':3}

* OSI-7Layer
1.데이터링크 계층: 한 노드에서 다른 노드로 프레임을 전송하는 책임을 갖는 층(Layer),송수신 측 속도 차이 해결을 위한 흐름제어 기능, 오류 검출과 회복을 위한 오류 제어 기능,
프레임 시작 및 끝을 구분하기 위한 동기화 기능, 프레임 순서적 전송을 위한 순서 제어 기능
2.물리 계층: 전송에 필요한 장치 간 실제 접속
3.세션: 송수신 측 간 관련성 유지 및 대화 제어/ 체크점(동기점)을 두어 정보 수신상태 체크
4.응용: 사용자가 OSI 환경에 접근 가능하도록 서비스 제공
5.네트워크:패킷을 발신지로부터 최종 목적지까지 전달하는 책임,패킷에 발신지와 목적지의 논리 주소를 추가,라우터 또는 교환기는 패킷 전달을 위해 경로를 지정하거나 교환 기능을 제공

* 메모리 관리 기법
- worst fit(최악 적합): 들어갈 수 있는 곳 중 낭비가 젤 심하게 들어가기
- first fit(최초 적합) : 들어갈 수 있는 곳 중 가장 빠른 영역에 들어감
- best fit(최적) : 들어갈 수 있는 곳 중 가장 낭비 덜한 곳

* TCP 프로토콜
1.패킷의 전송 및 오류를 제어
2.흐름 제어(flow control)의 기능 수행
-Slow Start:패킷이 문제없이 도착하면 혼잡 윈도우 크기를 패킷마다 1씩 증가시켜 한 주기가 지나면 혼잡 윈도우 크기가 2배로 되지만, 혼잡 현상 발생시 혼잡 윈도우 크기를 1로 줄여버리는 방식
-Sliding Window:한 번에 여러 패킷(프레임)을 전송할 수 있어 전송 효율이 좋은 기법,수신 측으로부터 이전에 송신한 패킷에 대한 긍정 수신 응답(ACK)이 전달된 경우 윈도우 크기는 증가하고, 수신측으로부터 이전에 송신한 패킷에 대한 부정 수신 응답(NAK)이 전달된 경우 윈도우 크기는 감소한다.
-Congestion Avoidance(혼잡 방지, Congestion Control): 네트워크 내에서 패킷의 지연이 너무 높아지게 되어 트래픽이 붕괴되지 않도록 패킷의 흐름을 제어하는 트래픽 제어(종류: AMID, Slow Start)
3.전이 중(full duplex) 방식의 양항뱡 가상회선 제공
4.전송 데이터와 응답 데이터를 함께 전송

* 논리주소와 물리주소
-논리주소: (세그먼트번호, 변위값)
-물리주소: '세그먼트 시작주소+변위값'

* 페이지 교체 page replacement 알고리즘
1.OPT - optimal: 앞으로 가장 오랫동안 사용되지 않을 페이지 교체
2.LRU - least recently used : 가장 오래 사용안한거 교체
3.LFU - least frequently used: 참조횟수 젤 적은거
4.MFU - most frequently used:  ''  젤 많은거
5.NUR - not used recently: 최근에 사용x 페이지
XX 오답: FIFO(선입선출)XX

* 교착상태 해결 방법
-탐지 detection : 교착상태 발생을 허용하고 발생 시 원인을 규명하여 해결 ex자원할당그래프
-회피 avoidance : 교착상태 가능성을 배제하지 않고 적절하게 피해나가는 방법 ex은행원 알고리즘 banker's algorithm
-복구 recovorey : 교착상태 발견 후 현황대기를 배제시키거나 자원을 중단하는 메모리 할당 기법 ex 선점, 프로세스 중지(희생자 선택)
-예방 prevention : 교착상태 필요조건을 부정함으로써 교착상태가 발생하지 않도록 미리 예방(ex 환형대기, 비선점, 점유와 대기, 상호배제 4가지 부정)

* 연산자의 우선순위
우선순위 높음  -> 우선순위 낮음
증감 연산자( ++ -- ) → 산술 연산자( * / % ) → 산술 연산자( +   - ) 
→ 시프트 연산자( << >> ) → 관계 연산자(=< => < > ) → 관계 연산자( == != ) 
→ 비트 연산자( & ^ | ) → 논리 연산자( && ||) → 조건연산자(?:) 
→ 대입연산자(= += *= /= %= <<= >>=) → 순서 연산자( , )

* 프로세스 상태의 종류
-보류 pending
-준비 ready
-제출 submit
-접수 hold
-실행 running
-대기 wait
-보류, 블록blocked
-교착 deadlock
-완료,종료 terminated,exit

* 결합도 순서(약한순 자스제외공내 강한순 내공외제스자)
- 자료 결합도
- 스탬프 결합도
- 제어 결합도
- 외부 결합도
- 공통 결합도
- 내용 결합도

**5과목**
* 소프트웨어 개발에서 정보보안 3요소 ..  무기가!!
1.무결성: 인가된 사용자만 수정 가능, 전송중인건 수정 안됨
2.기밀성:인가된 사용자만 접근 가능
3.가용성:인가된 사용자는 가진 권한 내에서 언제든 접근 가능

* SSH secure shell
-기본네트워크 포트는 22번이다
-전송되는 데이터는 암호화된다
-키를 통한 인증은 클라이언트의 공개키를 서버에 등록해야 한다
-서로 연결되어 있는 컴퓨터 간 원격 명령 실행이나 셀 서비스 등을 수행한다.

* PaaS-TA
-한국지능정보사회진흥원NIA가 지원하는 개방형 클라우드 플랫폼
-오픈 소스 기반의 platform as a service로서 PaaS-TA의 TA는 PaaS에 올라 타의 의미..
-2016년 4월 버전 1.0 파스타가 공개, 2021년 2월 5.5 버전 세미나가 출시되어
차세대 전자정부 클라우드에 적용되어 전자정부 서비스의 표준 개발, 운영환경을 제공하는 역할을 수행

* 정보시스템 접근 제어 방법, 정보보안을 위한 접근통제 정책 종류
1.강제접근통제MAC mandatory access control: 주체와 객체의 등급을 비교하여 접근 권한 부여
2.임의접근통제DAC discretionary access control: 접근하는 사용자의 신원에 따라 접근 권한 부여
3.사용자계정컨트롤 user access control: 프로그램에서 관리자 수준의 권한이 필요한 작업을 수행할 때 사용자에게 알려서 제어를 돕는 기능
4.자료별 접근통제 data-label access control>label-based access control: 
개별 행, 열에 대해 쓰기 권한, 읽기 권한을 가졌는지를 명확하게 결정
5.역할 기반 접근통제RBAC role-based access control: 권한이 있는 사용자들만 접근할 수 있는 보안 방법

* 어쩌구 방법론들
-구조적 개발 방법론: 정형화된 분석 절차에 따라 사용자 요구사항을 파악하여 문서화하는 처리 중심의 방법론
-객체 지향 개발 방법론: 현실 세계의 개체를 기계의 부품처럼 하나의 객체로 만들어,
소프트웨어를 개발할 때 기계의 부품을 조립하듯이 객체들을 조립해서 필요한 소프트웨어를 구현
-정보공학 방법론: 정보 시스템의 개발을 위해 계획, 분석, 설계, 구축에 정형화된 기법들을
상호 연관성 있게 통합 및 적용하는 자료 중심의 방법론
-컴포넌트기반 방법론: 기존의 시스템이나 소프트웨어를 구성하는 컴포넌트를 조합하여 하나의 새로운 애플리케이션을 만듬

* IT 스토리지 기술
- 소프트웨어 정의 스토리지 Software-defined storage SDS: 스토리지에 가상화를 적용
소프트웨어로 전체 스토리지 자원을 관리하여 하나의 저장장치처럼 사용할 수 있도록 하는 기법
* 초고속 근접무선통신 NFC 기술
- Zing 징~

* 서비스 지향 아키텍쳐 기반 애플리케이션 SOA service oriented architecture 계층
1.표현 계층
2.프로세스 계층
3.서비스 계층
4.비즈니스 계층
5.영속 계층

* 라우팅 프로토콜 OSPF open shortest path first
1.네트워크 변화에 신속하게 대처 가능
2.멀티캐스팅 지원
3.최단 경로 탐색에 dijkstra 알고리즘 사용
4.링크 상태 알고리즘 사용

* RIP
-거리 벡터 라우팅 프로토콜

* 시스템 침입 탐지 및 무결성 도구
0.Cron: 작업 예약 스케줄러- (초)/분/일/시간/월/요일/(년도)
1.Tripwire: 크래커가 침입해서 백도어를 만들거나 설정 파일을 변경했을 때 분석 MD5, CRC-32, SHA등의 알고리즘 사용
2.Aide: Tripwire를 대신할 수 있는 도구로 파일의 무결성을 검사하는 데 사용
3.sXid: MD5 체크섬을 사용하여 suid, sgid 파일을 추적 루트키트가 설치되어있는지 검사. Cron 작업 형태로 수행. 자동으로 파일 추적, 경고
4.Claymore: 침입탐지 및 무결성 모니터링 도구로 크론 테이블을 이용하여 주기적으로 파일시스템의 변조 유무를 확인. 변조되었을 경우 관리자에게 메일로 통보.
5. Samhain: 시스템의 무결성 점검. 여러 시스템 관리. 모니터링 에이전트, 중앙 로그서버로 구성
6.Slipwire: 파일 시스템의 무결성 검사. 파일의 SHA-1 hashes값을 비교하여 변경될 경우 사용자에게 경고
7.Fcheck: 유닉스 파일시스템의 변조유무를 점검하기 위한 PERL script 도구로 syslog, console 등으로 관리자에게 파일시스템 변화를 경보해줌. tripwire와 비슷한 도구로 보다 설치 및 운영이 쉬움
중요한거 Cron하고 Tripwire..

* 시스템
1.Hadoop(하둡): 오픈 소스를 기반으로 한 분산 컴퓨팅 플랫폼, 대형 스토리지, 빅데이터 관련
2.MapReduce: 대용량 데이터를 분산처리하기 위한 목적으로 개발된 프로그래밍 모델. 구글이 고안. 임의의 순서로 분산 처리 후 다시 합침
3.Apache: 월드 와이드 웹 컨소시엄(W3C)에서 사용하고 아파치 재단에서 관리 및 운영하는 서버용 오픈소스 소프트웨어
4.Honeypot: 비정상적인 접근의 탐지를 위해 의도적으로 설치해둔 시스템

* 소프트웨어 개발 프레임워크
-반제품 상태의 제품을 토대로 도메인별로 필요한 서비스 컴포넌트를 사용하여 재사용성 확대와 성능을 보장 받을 수 있게 하는 개발 소프트웨어
-설계 관점에 개발 방식을 패턴화시키기 위한 노력의 결과물인 소프트웨어 디자인 패턴을 반제품 소프트웨어 상태로 집적화시킨 것
-프레임워크의 동작 원리를 그 제어 흐름의 일반적인 프로그램 흐름과 반대로 동작한다고 해서 IoC(Inversion of Control)이라고 설명하기도 한다.
XX 오답 '사용자 코드에서 프레임워크를 호출해서 사용하고, 그에 대한 제어도 사용자 코드가 가지는 방식'은 라이브러리임 XX

* 파이썬 기반의 웹 크롤링 프레임워크: Scrapy 가볍고 빠르고 확장성 좋음
* Li-fi: 스펙트럼의 빛을 이용한 5세대 이동 통신 기술
* 위성항법보강시스템 SBAS : GPS 오차를 보정해 신뢰성과 안정성을 높인 기법

* 암호화 방식
1.양방향
- 개인키
스트림 방식
-RC4: MIT의 라이베스트, 샤미르, 애들멈ㄴ에 의해 제안된 공개키 암호화 알고리즘
-LFSR (대칭키 암호화 방식임, 비트/바이트/단어들을 순차적으로 암호화함)
블록 방식(대칭키)
-DES: 구 미국 표준. 56비트 키를 사용
-SEED
-AES: DES의 보안 취약점을 대체하기 위해 고안된 미국 표준 방식으로 현재 표준 대칭키 암호화 기법
-ARIA: SEED 이후로 나온 대한민국의 국가 암호 표준(AES와 동일)
공개키(비대칭키)
-RSA: 공개키 암호화 기법의 사실상 표준. 매우 큰 수의 소인수분해가 수학적으로 어렵다는 이론에 기반
-ECC: RSA의 키 길이가 너무 긴 결점을 보완하기 위해 타원곡선함수를 이용한 암호화 기법
-DSS(DSA): 디지털 서명 표준 인증서 서비스
-PKI: 공개키 기반 구조
-PEM: SSL 인증서 종류
2.단방향
 해시 암호화

* IPSec IP Security
-IP계층(3계층)에서 무결성과 인증 보장하는 인증헤더와 기밀성 보장하는 암호화 이용해
양 종단 구간에 보안 서비스 제공하는 터널링 프로토콜
-IKE(Internet Key Exchange) : 보안 관련 설정들을 생성, 협상 및 관리하는 프로토콜
(udp500번 포트 사용)
-ESP(Encapsulating Security Payload) : 메세지 인증코드,암호화 이용해 
"인증(무결성)","발신지인증","기밀성" 제공 프로토콜
-AH(Authentication Header) : 기밀성 제외한 메시지 인증코드 이용한 
"인증(무결성)","발신지인증"제공 프로토콜

* 소프트웨어 완성시키는 방법
- 합성 중심 composition-based: 전자 칩과 같은 소프트웨어 부품, 즉 블록(모듈)을 만들어서 끼워맞추어 소프트웨어를 완성시킴.
- 생성 중심 generation-based: 추상화 형태로 쓰여진 명세를 구체화하여 프로그램 만듬.

* CBD component based development
컴포넌트 조합후 하나의 애플리케이션 만드는 방법론
개발준비→분석→설계→구현→테스트→전개→인도 절차로 진행됨
-생산성과 품질을 높이고, 유지보수 비용을 최소화할 수 있다.
-컴포넌트 제작 기법을 통해 재사용성을 향상시킨다.
-독립적인 컴포넌트 단위의 관리로 복잡성을 최소화할 수 있다.

* authentication 자신의 신원을 시스템에 증명하는 과정. 아이디와 패스워드를 입력하는 과정이 가장 일반적인 예시임

* 맵 리듀스 mapreduce
- 맵(Map) : 데이터가 텍스트 형태로 입력되면 64KB 분할한다. 텍스트 안에 단어를 분류하여 카운트한다.
- 리듀스(Reduce) : 각 텍스트에서 정리된 맵들을 결합하여 동일한 단어를 카운트한다.

* PERT 차트
-작업들 간의 상호 관련성, 결정경로, 경계시간, 자원할당 등을 제시한다
-네트워크 도표를 작성한다.

* GANTT 차트
1.각 작업들이 언제 시작하고 언제 종료되는지에 대한 일정을 막대 도표를 이용하여 표시한다.
2. 시간선 차트라고도 한다.
3.수평 막대의 길이는 각 작업의 길이를 나타낸다.

* DDos 공격
네트워크 취약점이 있는 호스트들을 탐색한 후 이를 호스트들에 분산 서비스 공격용 툴을 설치하여 에이전트(agent)로 만든 후 DDoS공격에 이용
여기서 분산 서비스 공격용 툴의 종류
1.Trin00
2.TFN(Tribe Flooding Network)
3.TFN2K
4.Stacheldraht

* 생명주기 모형
폭포수 모형
Boehm이 제시한 고전적 생명주기 모형으로서 선형 순차적 모델 또는 고전적 생명주기 모형이라고도 하며,
[ 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수 ]의 단계를 통해 소프트웨어를 개발하는 모형
가장 오래된 모형으로 많은 적용 사례가 있지만 요구사항의 변경이 어려우며,
각 단계의 결과가 확인 되어야지만 다음 단계로 넘어간다.

프토토타입 모형
발주자나 개발자 모두에게 공동의 참조 모델을 제공하여
사용자의 요구사항을 충분히 분석할 목적으로 시스템의 일부분 또는 시제품을 일시적으로 간결히 구현하여 요구사항을 반영하는 개발 모델
유지보수가 없어지고 개발 단계안에서 유지보수가 이루어진다고도 볼 수 있다.

COCOMO 모델 : 보헴이 고안한 SW 비용 추정 모형
man-month=투입 노력
유형
1.조직형 organic(5만라인)
2.반분리형 semi-detached (30만라인 이하)
3.내장형 embedded (30만라인 이상)
종류
1.기본형 basic
2.중간형 intermediate
3.발전형 detailed

* 나선형 모델 (spiral model)
- 폭포수 프로토타입의 장점에 위험 분석 기능을 추가, 여러번의 개발 과정을 거쳐 점진적으로 완벽한 SW를 개발하는 것.

* nmap: 서버에 열린 포트 정보를 스캐닝해서 보안취약점을 찾는데 사용하는 도구

* mkdir: 디렉토리를 생성하는 명령어

*ftp: 응용계층 프로토콜

* 비용 산정 기법
1. Effort Per Task 기법 - (LOC기법을 보완하기위함)각 기능을 구현시키는 데 필요한 노력을 생명 주기의 각 단계별로 산정
2. 전문가 감정 기법 - 두 명이상의 전문가에게 비용 산정을 의뢰하는 기법, 개인적이고 주관적
3. 델파이 기법 - (전문가감정 기법의 주관적인 편견 보완하기위함)한명의 조정자와 여러 전문가의 의견을 종합하여 산정하는 기법
4. LOC기법 - 원시코드라인수(source line of code)의 비관치, 낙관치, 기대치를 측정 예측치 구함, 본문문제내용동일.
cf. 2&3의 경우 - 하향식 비용 산정 기법이며 1&4의 경우 상향식 비용 산정 기법이다.

* ICMP Internet Control Message Protocol
- IP 동작에서 네트워크 진단이나 제어 목적으로 사용
ICMP Flooding
- 서비스 거부DoS 공격의 한 방법으로 사용
- 보통 스머프 공격(Smurf Attack)이라고 부름
- 공격 방법에는 "Ping Flooding"과 "SYN Flooding"이 있음
Ping Flooding
- 공격대상에 막대한 양의 ICMP 에코 요청 패킷(ping)을 보내는 방법
- 보내는 쪽의 네트워크 대역폭이 대상 시스템이 확보한 네트워크 대역폭보다 더 크면 됨
SYN Flooding
- 막대한 양의 TCP SYN 패킷을 대상 시스템으로 보내서 시스템을 마비 시키는 공격 방법

